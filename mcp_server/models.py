# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:28:10+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field, RootModel


class Paginator(BaseModel):
    nextPageSelector: Optional[str] = Field(None, examples=['.page-link'])
    pageNum: Optional[int] = Field(None, examples=[10])


class Action1(BaseModel):
    ignoreIfNotPresent: Optional[bool] = Field(None, examples=[False])
    selector: Optional[str] = Field(
        None,
        description='Must be a valid CSS Selector',
        examples=['#search-form-editbox'],
    )
    value: Optional[str] = Field(
        None, description='The value to input.', examples=['web scraper']
    )


class Action2(BaseModel):
    ignoreIfNotPresent: Optional[bool] = Field(None, examples=[False])
    selector: Optional[str] = Field(
        None,
        description='Must be a valid CSS Selector',
        examples=['#search-form-editbox'],
    )
    value: Optional[str] = Field(
        None,
        description='Sequence of keys to send. Keys can include keystrokes such as ALT+A, ENTER, BACKSPACE, etc.',
        examples=['web scraper'],
    )


class Action3(BaseModel):
    ignoreIfNotPresent: Optional[bool] = Field(
        None,
        description='This optional parameter is useful when the target element occasionally may not be present in the DOM.',
        examples=[False],
    )
    selector: Optional[str] = Field(
        None, description='Must be a valid CSS Selector', examples=['.click-me']
    )
    skipLastIteration: Optional[bool] = Field(
        None,
        description='It is only used for click action inside a loop only. Skips the last iteration.',
        examples=[True],
    )


class Action4(BaseModel):
    ignoreIfNotPresent: Optional[bool] = Field(
        None,
        description='This optional parameter is useful when the target element occasionally may not be present in the DOM.',
        examples=[False],
    )
    selector: Optional[str] = Field(
        None, description='Must be a valid CSS Selector', examples=['.double-click-me']
    )
    skipLastIteration: Optional[bool] = Field(
        None,
        description='It is only used for click action inside a loop only. Skips the last iteration.',
        examples=[True],
    )


class Action5(BaseModel):
    ignoreIfNotPresent: Optional[bool] = Field(
        None,
        description='This optional parameter is useful when the target element occasionally may not be present in the DOM.',
        examples=[False],
    )
    selector: Optional[str] = Field(
        None,
        description='Must be a valid CSS Selector for the target element.',
        examples=['.js-click-me'],
    )
    skipLastIteration: Optional[bool] = Field(
        None,
        description='It is only used for click action inside a loop only. Skips the last iteration.',
        examples=[True],
    )


class Action6(BaseModel):
    selector: Optional[str] = Field(
        None,
        description='Must be an any valid CSS Selector inside the parent form to submit.',
        examples=['.some-element-inside-form'],
    )


class Action7(BaseModel):
    selector: Optional[str] = Field(
        None,
        description='Must be a valid CSS Selector for the target element.',
        examples=[':root'],
    )


class Action8(BaseModel):
    selector: Optional[str] = Field(
        None,
        description='Must be a valid CSS Selector for the target element.',
        examples=['#some-element'],
    )


class Action9(BaseModel):
    waitDelay: Optional[str] = Field(
        None, description='Wait time (in milliseconds).', examples=['5000']
    )


class Action10(BaseModel):
    script: Optional[str] = Field(
        None,
        description='The JavaScript snippet to run',
        examples=['console.log("It works!")'],
    )


class Action12(BaseModel):
    skipLastIteration: Optional[bool] = Field(
        None,
        description='It is only used for loop actions only. Skips the last iteration.',
        examples=[True],
    )


class Action13(BaseModel):
    scrollByPixels: Optional[float] = Field(
        None,
        description="Scrolls a web page by the number of pixels specified by 'scrollByPixels' parameter.",
        examples=[650],
    )
    scrollingElementSelector: Optional[str] = Field(
        None,
        description='Optionally specify here a valid CSS Selector of scrolling element.',
        examples=['#scroll-panel'],
    )
    selector: Optional[str] = Field(
        None,
        description="Some websites require clicking 'More' button while scrolling a page. Put here 'More' button valid CSS Selector.",
        examples=['.more-button'],
    )
    times: Optional[int] = Field(
        None, description='The number of times to scroll down a web page.', examples=[3]
    )


class Output(Enum):
    buffer = 'buffer'
    file = 'file'


class Type(Enum):
    base = 'base'
    chrome = 'chrome'


class Attr(Enum):
    text = 'text'
    href = 'href'
    src = 'src'
    alt = 'alt'


class Name(Enum):
    trim = 'trim'
    normal = 'normal'
    uppercase = 'uppercase'
    lowercase = 'lowercase'
    capitalize = 'capitalize'
    concatinate = 'concatinate'


class Filters(BaseModel):
    name: Optional[Name] = None


class Filters1(BaseModel):
    name: Optional[str] = Field(None, examples=['regex'])
    param: Optional[str] = Field(None, examples=['[\\\\d.]+'])


class Type1(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class SameSite(Enum):
    unspecified = 'unspecified'
    strict = 'strict'
    lax = 'lax'
    no_restriction = 'no_restriction'


class InitialCookie(BaseModel):
    domain: Optional[str] = Field(None, examples=['.twitter.com'])
    expirationDate: Optional[float] = Field(None, examples=[1762900726.409761])
    hostOnly: Optional[bool] = Field(None, examples=[False])
    httpOnly: Optional[bool] = Field(None, examples=[False])
    id: Optional[float] = Field(None, examples=[1])
    name: Optional[str] = Field(None, examples=['auth_token'])
    path: Optional[str] = Field(None, examples=['/'])
    sameSite: Optional[SameSite] = None
    secure: Optional[bool] = Field(None, examples=[True])
    session: Optional[bool] = Field(None, examples=[True])
    storeID: Optional[str] = Field(None, examples=['1'])
    value: Optional[str] = Field(None, examples=['46fd9fed1ab8b0b0e231ac3f'])


class Format(Enum):
    csv = 'csv'
    json = 'json'
    jsonl = 'jsonl'
    excel = 'excel'
    xml = 'xml'


class PaperSize(Enum):
    A3 = 'A3'
    A4 = 'A4'
    A5 = 'A5'
    A6 = 'A6'
    Letter = 'Letter'
    Legal = 'Legal'
    Tabloid = 'Tabloid'


class Format2(Enum):
    png = 'png'
    jpeg = 'jpeg'


class ParsePostResponse(BaseModel):
    pass


class SerpPostResponse(BaseModel):
    pass


class Action11(BaseModel):
    actions: Optional[List[Action]] = Field(
        [], description='list of actions combined in the loop are executed step-by-step'
    )
    times: Optional[float] = Field(
        None,
        description="the number of times to execute the wrapped actions within the 'loop .. times' construction.",
        examples=[5],
    )


class Action(
    RootModel[
        Union[
            Action1,
            Action2,
            Action3,
            Action4,
            Action5,
            Action6,
            Action7,
            Action8,
            Action9,
            Action10,
            Action11,
            Action12,
            Action13,
        ]
    ]
):
    root: Union[
        Action1,
        Action2,
        Action3,
        Action4,
        Action5,
        Action6,
        Action7,
        Action8,
        Action9,
        Action10,
        Action11,
        Action12,
        Action13,
    ] = Field(..., title='Action')


class Fetchrequest(BaseModel):
    actions: Optional[List[Action]] = Field(
        [],
        description='Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages. _(Chrome fetcher type only)_',
    )
    ignoreHTTPStatusErrCodes: Optional[bool] = Field(
        None,
        description='The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."',
    )
    initialCookies: Optional[List[InitialCookie]] = Field(
        [],
        description='The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.',
    )
    output: Optional[Output] = Field(
        'buffer',
        description='If set to _file_, the content of downloaded HTML is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, downloaded content is returned in the response body.',
    )
    proxy: Optional[str] = Field(
        None,
        description='Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.',
        examples=['country-sk'],
    )
    type: Type = Field(
        ...,
        description='If set to `base`, the Base fetcher is used for downloading web page content. Use `chrome` for fetching content with a Headless chrome browser. If omitted `base` fetcher is used by default.',
    )
    url: str = Field(..., description='Specify URL to download.')
    waitDelay: Optional[float] = Field(
        None,
        description='Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load. _(Chrome fetcher type only)_',
    )


class FieldModel(BaseModel):
    attrs: List[Attr] = Field(
        ...,
        description='A set of attributes to extract from a Field. Find more information about attributes',
    )
    details: Optional[Parserequest] = Field(
        None,
        description='Details themself represent independent Parse request that extracts data from linked pages.',
    )
    filters: Optional[List[Union[Filters, Filters1]]] = Field(
        None,
        description='Filters are used to pre-processing of text data when extracting.',
    )
    name: str = Field(..., description='Field name is used to aggregate results.')
    selector: str = Field(
        ...,
        description='Selector represents a CSS selector for data extraction within the given block.',
        examples=['#cards a'],
    )
    type: Type1 = Field(
        ..., description='Selector type. ( 0 - image, 1 - text, 2 - link)'
    )


class Parserequest(BaseModel):
    commonParent: Optional[str] = Field(
        None,
        description='Specifies common ancestor block for a set of fields used to extract data from a web page. _(CSS Selector)_',
        examples=['.common-block'],
    )
    fields: List[FieldModel] = Field(
        ...,
        description='Define a  set of fields used to extract data from a web page. A Field represents a given chunk of extracted data from every block on each page.\n',
    )
    format: Format = Field(
        ...,
        description='Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.',
        title='Format',
    )
    name: str = Field(..., description='Collection name.')
    paginator: Optional[Paginator] = None
    path: Optional[bool] = Field(
        False,
        description='Path is a special parameter specifying navigation pages only. It collects information from detailed pages. No results from the current page return. Defaults to false.',
        title='Path',
    )
    request: Optional[Fetchrequest] = None


class Serprequest(BaseModel):
    fields: Optional[List[FieldModel]] = Field(
        None,
        description='Specify CSS selectors (patterns) used to gather data from Search Engine Result Pages.\n\nReady-to-use payloads for collecting search results from the most popular Search Engines are available. These payloads are customizable, though.\n',
    )
    format: Format = Field(
        ...,
        description='Extracted data is returned either in CSV, MS Excel, JSON, JSON(Lines) or XML format.',
        title='Format',
    )
    name: str = Field(..., description='Collection name.')
    pageNum: Optional[int] = Field(1, description='Specify number of pages to crawl.')
    proxy: str = Field(
        ...,
        description='Always specify proxy for sending SERP requests. Add choosen [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.',
        examples=['country-any'],
    )
    type: str = Field(
        ...,
        description='For SERP requests you should _always_ use `chrome` type to fetch content with a Headless chrome browser',
        examples=['chrome'],
    )
    url: str = Field(
        ...,
        description='url holds the link to a Search Engine to use, and other optional parameters like languages or country.',
    )


class Url2pdfrequest(BaseModel):
    actions: Optional[List[Action]] = Field(
        [],
        description='Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages.',
    )
    ignoreHTTPStatusErrCodes: Optional[bool] = Field(
        None,
        description='The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."',
    )
    initialCookies: Optional[List[InitialCookie]] = Field(
        [],
        description='The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.',
    )
    landscape: Optional[bool] = Field(
        False,
        description='Paper orientation. Parameter landscape = false means portrait orientation. Set landscape to true for landscape page oriantation.',
    )
    marginBottom: Optional[float] = Field(
        0.4, description='Bottom Margin of the PDF (in inches)'
    )
    marginLeft: Optional[float] = Field(
        0.4, description='Left Margin of the PDF (in inches)'
    )
    marginRight: Optional[float] = Field(
        0.4, description='Right Margin of the PDF (in inches)'
    )
    marginTop: Optional[float] = Field(
        0.4, description='Top Margin of the PDF (in inches)'
    )
    output: Optional[Output] = Field(
        'buffer',
        description='If set to _file_, the resulted PDF is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, PDF content is returned in the response body.',
    )
    pageRanges: Optional[str] = Field(
        None,
        description='Specify page ranges to convert. Defaults to the empty value, which means convert all pages.',
        examples=['1-4, 6, 10-12'],
    )
    paperSize: Optional[PaperSize] = Field(
        'A4',
        description='Page size parameter consists of the most popular page formats.',
    )
    printBackground: Optional[bool] = Field(
        False, description='Print background graphics in the PDF.'
    )
    printHeaderFooter: Optional[bool] = Field(
        False,
        description='printHeaderFooter  parameter consists of the date, name of the web page, the page URL, and how many pages the document you are printing.',
    )
    proxy: Optional[str] = Field(
        None,
        description='Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.',
        examples=['country-any'],
    )
    scale: Optional[float] = Field(
        1,
        description='By default, PDF document content is generated according to dimensions of the original web page content. Using the `scale` parameter, you can specify a custom zoom factor from 0.1 to 5.0 of the webpage rendering.',
    )
    url: str = Field(
        ...,
        description='The full URL address (including HTTP/HTTPS) of a web page that you want to save as PDF',
    )
    waitDelay: Optional[float] = Field(
        0.5,
        description='Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load.',
    )


class Url2screenshotrequest(BaseModel):
    actions: Optional[List[Action]] = Field(
        [],
        description='Use actions to automate manual workflows while rendering web pages. They simulate real-world human interaction with pages.',
    )
    clipSelector: Optional[str] = Field(
        None,
        description='Captures a screenshot of specified CSS element on a web page.',
        examples=['#css-element'],
    )
    format: Optional[Format2] = Field(
        'png', description='Sets the Format of output image'
    )
    fullPage: Optional[bool] = Field(
        False,
        description='takes a screenshot of a full web page. It ignores offsetX, offsety, width and height argument values.',
    )
    height: Optional[int] = Field(
        600, description='Rectangle height in device independent pixels (dip).'
    )
    ignoreHTTPStatusErrCodes: Optional[bool] = Field(
        None,
        description='The HTTP 200 OK success status response code indicates that the request has succeeded. Sometimes a server returns normal HTML content even with an erroneous Non-200 HTTP response status code. The IgnoreHTTPStatusCode option is useful when you need to force the return of HTML content. Defaults to "false."',
    )
    initialCookies: Optional[List[InitialCookie]] = Field(
        [],
        description='The "Initial Cookies" option is useful for crawling websites that require a login. The simplest solution to get an array of cookies for specific websites is to use a web browser "EditThisCookie" extension. Copy a cookie array with "EditThisCookie" and paste it into the "Initial cookie" field.',
    )
    offsetx: Optional[int] = Field(
        0, description='X offset in device independent pixels (dip).'
    )
    offsety: Optional[int] = Field(
        0, description='Y offset in device independent pixels (dip).'
    )
    output: Optional[Output] = Field(
        'buffer',
        description='If set to _file_, the resulted screenshot is uploaded to Dataflow Kit Storage first. Then the link to this file is returned. Overwise, web site screenshot is returned in the response body.',
    )
    printBackground: Optional[bool] = Field(
        False, description='Print background graphics in the PDF.'
    )
    proxy: Optional[str] = Field(
        None,
        description='Specify proxy by adding [country ISO code](https://en.wikipedia.org/wiki/ISO_3166-2) to `country-` value to send requests through a proxy in the specified country. Use `country-any` to use random geo-targets.',
        examples=['country-any'],
    )
    quality: Optional[int] = Field(
        80,
        description='Sets the Quality of output image. Compression quality from range [0..100] (jpeg only).',
    )
    scale: Optional[float] = Field(
        1, description='Image scale factor. range [0.1 .. 3]'
    )
    url: str = Field(
        ...,
        description='The full URL address (including HTTP/HTTPS) of a web page that you want to capture',
    )
    waitDelay: Optional[float] = Field(
        0.5,
        description='Specify a wait delay (in seconds). This may be useful if certain elements of the web site need to be rendered after the initial page load.',
    )
    width: Optional[int] = Field(
        800, description='Rectangle width in device independent pixels (dip).'
    )


Action11.model_rebuild()
FieldModel.model_rebuild()
